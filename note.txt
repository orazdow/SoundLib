template class types (so far):

Ctl: msg, id, childs*, run()
Sig: float input, float output, float out(), out(dbl step)  
Env public sig: uint on, float out, float out(uint trig), void reset()
Voice public sig : uint on, float out(dbl step, int trig), float out(int note, int trig)
polyvoice public Voice : env* envs, int voices
--------------------------
poly --> setEnvs(Env* envs), setEnvs(Voice* voices), setPVoice(polyvoice p) 
--------------------------
add:
-cycle detection
-signal chain...
-input~, output~
-control params (in msg..)
-add msg format field 
-error handling on receive message side (wrong format)
-copy assignment operator
-option for seperate ctl, audio source callbacks
-portmidi wrapper
-glfw mode!
-----------
add:
filters
sinosc
fncgen
noise
fmosc
delay
wavplayer
fft
comb
ctl seq
note maps
-----------
now:
sig, env template, sinosc, ar env, voice, polyvoice, add init guard
-note types: [on/off(8)][note(8)][vel(16)], [ctl_t(8)][data[24]], [note(8)][vel(8)][pitch(14)][on/off(2)]
-list of msg formats
-signal chain...? a_glob.call->:osc.connect(filt.connect(out));
-in_fmt, out_fmt fields, Ctl* parent in class, fmt in msg
-use note type 1 for now, in voice, polyvoice
------------------------------------------------------
msg formats: [val(32)], [val(32)f], [val(16)][val(16)](note/on), 3 above note types^ (msg_type field) 
params struct: {32 floats}
--------------------------
enum msg_fmt { u32, u32_f, note }
